#!/usr/bin/perl

##########################################################
##  SHELL FOR END-OF-SENTENCE CLASSIFIER
##
##    hw1a.prl < sent.data.train sent.data.test
##
##  Suggestion: run in a wide window
##########################################################

$L="./classes";

&initialize_set(*abbrevs_,"$L/abbrevs"); 
&initialize_set(*titles_,"$L/titles"); 
&initialize_set(*sentence_,"$L/sentence_internal");
&initialize_set(*timeterms_,"$L/timeterms"); 

sub getFeatures() {
    my $line = shift;
    
    @words = split(' ', $_);
    
    my $R1 = $words[6];
    my $L1 = $words[4];
    
    $r1NewPara = $R1 eq "<P>" ? 1 : 0;
    $r1Special = $R1 =~ /[\.,;-]/ ? 1 : 0;
    $r1DoubleQ = $R1 eq "``" ? 1 : 0;
    $r1AllDigit = $R1 =~ /[0-9]+/ ? 1 : 0;
    $l1Upper = $L1 =~ /^[A-Z]$/ ? 1 : 0;
    
    $l1SentInt = &classmember($L1, sentence_) ? 1 : 0;
    $l1Title = &classmember($L1, titles_) ? 1 : 0;
    $l1Abbrev = &classmember($L1, abbrevs_)? 1 : 0;
    $l1Time = &classmember($L1, timeterms_)? 1 : 0;
       
    return ($r1NewPara, $r1Special, $r1DoubleQ, $r1AllDigit, $l1Upper, $l1Title, 
    	$l1Abbrev, $l1SentInt, $l1Time, $words[9], $words[10], $words[11], $words[0]);
}

sub createArffFile() {
	# Get file name to store data
    my $file_name = shift;
    
    # Delete previously created file
    unlink($file_name);
    
    # Start printing features to file
    open (MYFILE, '>>', $file_name) || die "Can't open file $file_name: $!";
    
    &printHeader(\*MYFILE);
    
    while (<>) {
    	local @feature_vector = &getFeatures($_);
    	
    	$" = ',';
        
        print MYFILE "@feature_vector[0..$#feature_vector]", "\n";
    }
    
    close (MYFILE);
}

sub printHeader {
    $MYFILE = $_[0];

    print { $MYFILE } "\@relation eos\n";
    
    print { $MYFILE } "\@attribute r1NewPara {0, 1}\n";
    print { $MYFILE } "\@attribute r1Special {0, 1}\n";
    print { $MYFILE } "\@attribute r1DoubleQ {0, 1}\n";
    print { $MYFILE } "\@attribute r1AllDigit {0, 1}\n";
    print { $MYFILE } "\@attribute l1Upper {0, 1}\n";
    print { $MYFILE } "\@attribute l1Title {0, 1}\n";
    print { $MYFILE } "\@attribute l1Abbrev {0, 1}\n";
    print { $MYFILE } "\@attribute l1SentInt {0, 1}\n";
    print { $MYFILE } "\@attribute l1Time {0, 1}\n";
    
    print { $MYFILE } "\@attribute lLength numeric\n";
    print { $MYFILE } "\@attribute rLength numeric\n";
    print { $MYFILE } "\@attribute Nspaces numeric\n";

    print { $MYFILE } "\@attribute class {EOS, NEOS}\n";
    print { $MYFILE } "\@data\n";
}
 
##########################################################
## RET - prints full line for errors and keeps score
##     - $where indicates the rule number responsible for the classification
##
##  This is a useful debugging tool, as after each change in
##  the program one can identify the remaining misclassified
##  training examples and the patterns responsible for them. 
##########################################################
 
sub ret {
   local($where,$trueclass,$id,$givenclass) = @_;
   
   if ($trueclass eq $givenclass) {
      print ".. (at ",$where,") -  ", $_;
      $correct++; 
   }
   else {
      print "XX (at ",$where,") -  ", $_;
      $incorrect++;
   }
   # next;
}

##########################################################
## CLASSMEMBER - tests for membership of $key in a given set
##
##  The \L in $set{"\L$key"} is a perl hack to convert a
##  string into all lower case for lookup in a word array
##  insensitive to the capitalization of the original key.
##########################################################

sub classmember{
   local($key,*set) = @_;

   return $set{"\L$key"};
}

##########################################################
## INITIALIZE_SET - loads named associative array with set members   
##########################################################

sub initialize_set{
   local(*set,$where) = @_;
   
    open (FILE,$where) || die "Can't open file $where: $!\n";

    while (<FILE>) {
        chop;
        $set{$_} = 1;
    }
    close (FILE);
}

&createArffFile("train.arff");

&createArffFile("test.arff");