#!/usr/bin/perl

##########################################################
##  SHELL FOR END-OF-SENTENCE CLASSIFIER
##
##    hw1a.prl < sent.data.train sent.data.test
##
##  Suggestion: run in a wide window
##########################################################

$L="./classes";

&initialize_set(*abbrevs,"$L/abbrevs"); 
&initialize_set(*titles,"$L/titles"); 
&initialize_set(*sentence_internal,"$L/sentence_internal");


sub getFeatures() {
    my $line = shift;
    my $class, $r1Ucfirst, $r1NewPara, $r1Comma, $r1Period, $l1Title, $l1Abbrev, $lLength, $rLength, $Nspaces, $r1Quote, $r1Semi, $l1Internal, $l1Cap;
    @words = split(' ', $line);
    ($class, $id, $L3, $L2, $L1, $c, $R1, $R2, $R3, $lLength, $rLength, $Nspaces) = @words;
    if ($R1 =~ /^[A-Z]/) {$r1Ucfirst = 1} else {$r1Ucfirst = 0}
    if ($R1 eq "<P>") {$r1NewPara = 1} else {$r1NewPara = 0}
    if ($R1 eq ".") {$r1Period = 1} else {$r1Period = 0}
    if ($R1 eq ",") {$r1Comma = 1} else {$r1Comma = 0}
    if (&classmember(lc($L1), titles)) {$l1Title = 1} else {$l1Title = 0}
    if (&classmember(lc($L1), abbrevs)) {$l1Abbrev = 1} else {$l1Abbrev = 0}
    if ($R1 eq "``") {$r1Quote = 1} else {$r1Quote = 0}
    if ($R1 eq ";") {$r1Semi = 1} else {$r1Semi = 0}
    if (&classmember(lc($L1), sentence_internal)) {$l1Internal = 1} else {$l1Internal = 0}
    if ($L1 =~ /^[A-Z]$/) {$l1Cap = 1} else {$l1Cap = 0}
       
    return ($class, $id, $r1Ucfirst, $r1NewPara, $r1Comma, $r1Period, $l1Title, $l1Abbrev, $lLength, $rLength, $Nspaces, $r1Quote, $r1Semi, $l1Internal, $l1Cap);
}

sub genResult() {
    while (<>) {

        local ($class, $id, $r1Ucfirst, $r1NewPara, $r1Comma, $r1Period, $l1Title, $l1Abbrev, $lLength, $rLength, $Nspaces, $r1Quote, $r1Semi, $l1Internal, $l1Cap) = &getFeatures($_);
        &ret($class, $id, &classify($class, $r1Ucfirst, $r1NewPara, $r1Comma, $r1Period, $l1Title, $l1Abbrev, $lLength, $rLength, $Nspaces, $r1Quote, $r1Semi, $l1Internal, $l1Cap));
        
    }

    print "Your score is: ", $correct/($correct+$incorrect), "\n";
}

sub createArffFile() {
    my $file_name = shift;
    unlink($file_name);
    open (MYFILE, '>>', $file_name) || die "Can't open file $file_name: $!";
    &printHeader(\*MYFILE);
    while (<>) {
        local ($class, $id, $r1Ucfirst, $r1NewPara, $r1Comma, $r1Period, $l1Title, $l1Abbrev, $lLength, $rLength, $Nspaces, $r1Quote, $r1Semi, $l1Internal, $l1Cap) = &getFeatures($_);
        print MYFILE $r1Ucfirst, ",", $r1NewPara, ",", $r1Comma, ",",  $r1Period, ",",  $l1Title, ",",  $l1Abbrev, ",",  $lLength, ",",  $rLength, ",",  $Nspaces, ",",  $r1Quote, ",",  $r1Semi, ",",  $l1Internal, ",",  $l1Cap, ",", $class, "\n";
    }
    close (MYFILE);
}

sub printHeader {
    $MYFILE = $_[0];

    print { $MYFILE } "\@RELATION eos\n";
    print { $MYFILE } "\@ATTRIBUTE r1Ucfirst {0, 1}\n";
    print { $MYFILE } "\@ATTRIBUTE r1NewPara {0, 1}\n";
    print { $MYFILE } "\@ATTRIBUTE r1Comma {0, 1}\n";
    print { $MYFILE } "\@ATTRIBUTE r1Period {0, 1}\n";
    print { $MYFILE } "\@ATTRIBUTE l1Title {0, 1}\n";

    print { $MYFILE } "\@ATTRIBUTE l1Abbrev {0, 1}\n";

    print { $MYFILE } "\@ATTRIBUTE lLength numeric\n";
    
    print { $MYFILE } "\@ATTRIBUTE rLength numeric\n";
    print { $MYFILE } "\@ATTRIBUTE Nspaces numeric\n";
    print { $MYFILE } "\@ATTRIBUTE r1Quote {0, 1}\n";

    print { $MYFILE } "\@ATTRIBUTE r1Semi {0, 1}\n";

    print { $MYFILE } "\@ATTRIBUTE l1Internal {0, 1}\n";

    print { $MYFILE } "\@ATTRIBUTE l1Cap {0, 1}\n";

    print { $MYFILE } "\@ATTRIBUTE class {EOS, NEOS}\n";
    print { $MYFILE } "\@DATA\n";
}
 
##########################################################
## RET - prints full line for errors and keeps score
##     - $where indicates the rule number responsible for the classification
##
##  This is a useful debugging tool, as after each change in
##  the program one can identify the remaining misclassified
##  training examples and the patterns responsible for them. 
##########################################################
 
sub ret {
   local($where,$trueclass,$id,$givenclass) = @_;
   
   if ($trueclass eq $givenclass) {
      print ".. (at ",$where,") -  ", $_;
      $correct++; 
   }
   else {
      print "XX (at ",$where,") -  ", $_;
      $incorrect++;
   }
   # next;
}

##########################################################
## CLASSMEMBER - tests for membership of $key in a given set
##
##  The \L in $set{"\L$key"} is a perl hack to convert a
##  string into all lower case for lookup in a word array
##  insensitive to the capitalization of the original key.
##########################################################

sub classmember{
   local($key,*set) = @_;

   return $set{"\L$key"};
}

##########################################################
## INITIALIZE_SET - loads named associative array with set members   
##########################################################

sub initialize_set{
   local(*set,$where) = @_;
   
    open (FILE,$where) || die "Can't open file $where: $!\n";

    while (<FILE>) {
        chop;
        $set{$_} = 1;
    }
    close (FILE);
}

&createArffFile("train.arff");

&createArffFile("test.arff");